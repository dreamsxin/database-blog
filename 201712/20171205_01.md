## [未完待续] SQL流式案例 - 旋转门压缩(前后计算相关滑窗处理例子)
                        
### 作者                        
digoal                        
                        
### 日期                        
2017-12-05                       
                        
### 标签                        
PostgreSQL , 阅后即焚 , 流计算 , 旋转门压缩 , 滑窗分析 , 上下文相关滑窗 , 上下结果相关滑窗  
                        
----                        
                        
## 背景         

在流计算应用中，保持窗口和数据可重算（设置起点重新开始算）并覆盖已有计算结果。是两个比较特殊但又很有用的需求。

例如流数据来自多个业务线，数据在现实中的发生有先后逻辑，然而由于系统的问题可能有数据到达差异，例如先发生的事情，数据反而后到达，（比如说订单，先下单，后付款，在发货，这是多个业务线产生的数据，然而是围绕同一笔订单，如果数据到达发生了错乱，可能出现付款、下单、发货的到达顺序，影响流计算的准确性，通过重算可以达到修复的目的。）

抽象成流计算的功能：

1、下一次计算可能依赖上一次计算的结果，

2、下一次计算可能需要用到之前计算用到的源数据，

3、下一次计算可能改变上一次计算的结果，

4、可以回溯到之前的某个时间点开始重算（计算前结果也需要回溯到之前的某个点）。

PostgreSQL UDF、阅后即焚、事务原子性、结果可持久化、支持INSERT ON CONFLICT写合并、flash back等技术点，可以很好的支撑上面的需求。

本文以旋转门压缩计算为例，给一个PostgreSQL处理这类流计算需求的设计思路和DEMO。


旋转门压缩的背景技术请参考：

[《PostgreSQL 三角函数的用法举例 - 已知3点求任意夹角（旋转门续）》](../201608/20160816_01.md)  

[《旋转门数据压缩算法在PostgreSQL中的实现 - 流式压缩在物联网、监控、传感器等场景的应用》](../201608/20160813_01.md)  


## 

1、保留窗口使用

2、


## 设计1 - 极致收敛窗口
第一种设计，窗口收敛，从倒数第一个有效点开始，到后面的所有记录，源数据都需要保持。



数据流


计算结果存储


断点



保存CTID数组

保存最后一个有效点后面所有点的CTID

下次消费，从最后一个有效点开始取批




## 设计2 - 可设置保留窗口

第二种设计，窗口收敛，从倒数第N个有效点开始，到后面的所有记录，源数据都需要保持。


由于数据到达时间的错乱，可能需要一个可调整的窗口

也就是说数据消费完后，不能


合并


重算，更新

insert on conflict () do update set xxx where xxx<>exclude.xxx



## DEMO







1、流计算结果，增加两个字段：状态、时间戳。

2、计算当前记录时，如果需要用到上一条流计算结果，使用UDF调用得到。

3、如有必要，更新上一条流计算结果的可见性（状态字段）。



create table t_result ( 
  grpid int,
  dt timestamp,
  info text
  state int2 default 1,                -- 0表示不可见，1表示可见
  ts timestamp clock_timestamp()       -- 流式记录写入时间戳
);

create index idx_t_result on t_result (grpid, ts); 


create table t_delta (
  grpid int,
  dt timestamp,
  info text,
  ts timestamp
);


获取当前统计维度的上一条记录

create or replace function get_upstream(v_grpid int) returns text as $$
  select info from t_result where grpid=$1 order by ts desc limit 1;
$$ language sql strict;


阅后即焚，将t_delta明细数据实时统计到t_result


## 相似案例
[《人、机客户服务质量 - 实时透视分析 - (多股数据流上下文相关实时分析,窗口保持)》](../201712/20171208_05.md)  

[《PostgreSQL 三角函数的用法举例 - 已知3点求任意夹角（旋转门续）》](../201608/20160816_01.md)  

[《旋转门数据压缩算法在PostgreSQL中的实现 - 流式压缩在物联网、监控、传感器等场景的应用》](../201608/20160813_01.md)  

[《HTAP数据库 PostgreSQL 场景与性能测试之 32 - (OLTP) 高吞吐数据进出(堆存、行扫、无需索引) - 阅后即焚(JSON + 函数流式计算)》](../201711/20171107_33.md)  

[《HTAP数据库 PostgreSQL 场景与性能测试之 31 - (OLTP) 高吞吐数据进出(堆存、行扫、无需索引) - 阅后即焚(读写大吞吐并测)》](../201711/20171107_32.md)  

[《HTAP数据库 PostgreSQL 场景与性能测试之 27 - (OLTP) 物联网 - FEED日志, 流式处理 与 阅后即焚 (CTE)》](../201711/20171107_28.md)  

[《在PostgreSQL中实现update | delete limit - CTID扫描实践  (高效阅后即焚)》](../201608/20160827_01.md)  

[《PostgreSQL 异步消息实践 - Feed系统实时监测与响应(如 电商主动服务) - 分钟级到毫秒级的实现》](../201711/20171111_01.md)  


## 

方法1，阅后即焚：

流计算结果表（即有效位点），增加2个字段：PK于明细表关联，时间戳代表最后一条记录。下次阅后即焚从最后一个有效位点开始，从明细表继续消费。

方法2，直接在明细表上更新状态（点、当前记录是否可见）。

其他，所有涉及到中间计算结果的，都可以用类似方法实现：

计算当前记录时，更新计算结果到当前记录上（也就是通过直接更新明细表的流计算方法）。如果计算时需要用到上一条或者上若干条流计算结果，通过递归，或者使用UDF调用都很容易得到。

例子

create table 明细表 (
  上报内容字段定义....,
  中间结果字段....,
  可见性状态字段....
);

## 参考
[《PostgreSQL flashback(闪回) 功能实现与介绍》](../201710/20171010_01.md)  
